name: Multi-AI Code Review Pipeline

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
  XAI_API_KEY: ${{ secrets.XAI_API_KEY }}

jobs:
  # Step 1: Get PR diff and files
  prepare:
    runs-on: ubuntu-latest
    outputs:
      diff: ${{ steps.diff.outputs.diff }}
      files: ${{ steps.files.outputs.files }}
      pr_number: ${{ steps.pr.outputs.number }}
      primary_ai: ${{ steps.routing.outputs.primary }}
      focus_area: ${{ steps.routing.outputs.focus }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR number
        id: pr
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "number=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Get PR diff
        id: diff
        run: |
          gh pr diff ${{ steps.pr.outputs.number }} > diff.txt || echo "No diff available" > diff.txt
          # Truncate by lines first (preserves code context)
          head -n 2000 diff.txt > truncated_diff.txt
          # Also cap by bytes for minified/long-line files (100KB max)
          head -c 102400 truncated_diff.txt > final_diff.txt
          # Base64 encode to preserve special characters
          DIFF_CONTENT=$(cat final_diff.txt | base64 -w 0)
          echo "diff=$DIFF_CONTENT" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed files
        id: files
        run: |
          gh pr view ${{ steps.pr.outputs.number }} --json files -q '.files[].path' > files.txt || echo "No files" > files.txt
          FILES_CONTENT=$(cat files.txt | head -100)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect file categories for smart routing
        id: routing
        run: |
          FILES=$(cat files.txt)

          # Security-related files -> prioritize Gemini
          SECURITY_MATCH=$(echo "$FILES" | grep -iE '(auth|crypto|secret|password|token|session|login|security)' | wc -l)

          # Architecture-related -> prioritize Claude
          ARCH_MATCH=$(echo "$FILES" | grep -iE '(config|setup|docker|k8s|infra|architecture|core)' | wc -l)

          # Test files -> prioritize GPT-4
          TEST_MATCH=$(echo "$FILES" | grep -iE '(test|spec|mock|__tests__)' | wc -l)

          # UI/component files -> prioritize GPT-4 + Claude
          UI_MATCH=$(echo "$FILES" | grep -iE '(component|screen|widget|view|ui|styles)' | wc -l)

          # Determine primary focus
          if [ "$SECURITY_MATCH" -gt 0 ]; then
            echo "primary=gemini" >> $GITHUB_OUTPUT
            echo "focus=security" >> $GITHUB_OUTPUT
          elif [ "$ARCH_MATCH" -gt 0 ]; then
            echo "primary=claude" >> $GITHUB_OUTPUT
            echo "focus=architecture" >> $GITHUB_OUTPUT
          elif [ "$TEST_MATCH" -gt 0 ]; then
            echo "primary=gpt4" >> $GITHUB_OUTPUT
            echo "focus=testing" >> $GITHUB_OUTPUT
          elif [ "$UI_MATCH" -gt 0 ]; then
            echo "primary=gpt4" >> $GITHUB_OUTPUT
            echo "focus=ui" >> $GITHUB_OUTPUT
          else
            echo "primary=all" >> $GITHUB_OUTPUT
            echo "focus=general" >> $GITHUB_OUTPUT
          fi

          echo "Security files: $SECURITY_MATCH, Arch files: $ARCH_MATCH, Test files: $TEST_MATCH, UI files: $UI_MATCH"

  # Step 2: Run AI reviews in parallel
  claude-review:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      review: ${{ steps.review.outputs.result }}
      success: ${{ steps.review.outputs.success }}
    steps:
      - name: Claude Architecture Review
        id: review
        uses: actions/github-script@v7
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          script: |
            const diff = Buffer.from('${{ needs.prepare.outputs.diff }}', 'base64').toString('utf-8');
            const files = `${{ needs.prepare.outputs.files }}`;

            // Skip if no API key
            if (!process.env.ANTHROPIC_API_KEY) {
              core.setOutput('result', '‚ö†Ô∏è Claude API key not configured');
              core.setOutput('success', 'false');
              return;
            }

            // Retry with exponential backoff for 429/5xx errors
            async function fetchWithRetry(url, options, maxRetries = 3) {
              for (let attempt = 0; attempt <= maxRetries; attempt++) {
                const response = await fetch(url, options);

                if (response.ok) return response;

                // Retry on 429 (rate limit) or 5xx (server errors)
                if ((response.status === 429 || response.status >= 500) && attempt < maxRetries) {
                  const retryAfter = response.headers.get('retry-after');
                  const parsedRetry = retryAfter ? parseInt(retryAfter) : NaN;
                  // Fall back to exponential backoff if retry-after is HTTP-date or unparseable
                  const delay = !isNaN(parsedRetry) ? parsedRetry * 1000 : Math.pow(2, attempt) * 1000;
                  console.log(`Rate limited (${response.status}). Retry ${attempt + 1}/${maxRetries} in ${delay}ms`);
                  await new Promise(r => setTimeout(r, delay + Math.random() * 500)); // Add jitter
                  continue;
                }

                return response; // Return non-retryable errors
              }
            }

            try {
              const response = await fetchWithRetry('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.ANTHROPIC_API_KEY,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-sonnet-4-20250514',
                  max_tokens: 2000,
                  messages: [{
                    role: 'user',
                    content: `You are an expert code architect. Review this PR diff for:
            1. Architectural concerns and design patterns
            2. Scalability issues
            3. Security vulnerabilities
            4. Performance implications

            Be concise. Format as markdown with severity levels (üî¥ Critical, üü° Warning, üü¢ Suggestion).
            If the diff is empty or unclear, say so briefly.

            Files changed:
            ${files}

            Diff:
            ${diff.substring(0, 60000)}`
                  }]
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                console.log('Claude API error:', response.status, errorText);
                core.setOutput('result', `‚ö†Ô∏è Claude API error: ${response.status}`);
                core.setOutput('success', 'false');
                return;
              }

              const data = await response.json();

              if (data.content && data.content[0] && data.content[0].text) {
                core.setOutput('result', data.content[0].text);
                core.setOutput('success', 'true');
              } else {
                core.setOutput('result', '‚ö†Ô∏è Claude returned empty response');
                core.setOutput('success', 'false');
              }
            } catch (error) {
              console.log('Claude error:', error.message);
              core.setOutput('result', `‚ö†Ô∏è Claude error: ${error.message}`);
              core.setOutput('success', 'false');
            }

  gpt4-review:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      review: ${{ steps.review.outputs.result }}
      success: ${{ steps.review.outputs.success }}
    steps:
      - name: GPT-4 Code Quality Review
        id: review
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        with:
          script: |
            const diff = Buffer.from('${{ needs.prepare.outputs.diff }}', 'base64').toString('utf-8');
            const files = `${{ needs.prepare.outputs.files }}`;

            if (!process.env.OPENAI_API_KEY) {
              core.setOutput('result', '‚ö†Ô∏è OpenAI API key not configured');
              core.setOutput('success', 'false');
              return;
            }

            // Retry with exponential backoff for 429/5xx errors
            async function fetchWithRetry(url, options, maxRetries = 3) {
              for (let attempt = 0; attempt <= maxRetries; attempt++) {
                const response = await fetch(url, options);
                if (response.ok) return response;
                if ((response.status === 429 || response.status >= 500) && attempt < maxRetries) {
                  const retryAfter = response.headers.get('retry-after');
                  const parsedRetry = retryAfter ? parseInt(retryAfter) : NaN;
                  const delay = !isNaN(parsedRetry) ? parsedRetry * 1000 : Math.pow(2, attempt) * 1000;
                  console.log(`Rate limited (${response.status}). Retry ${attempt + 1}/${maxRetries} in ${delay}ms`);
                  await new Promise(r => setTimeout(r, delay + Math.random() * 500));
                  continue;
                }
                return response;
              }
            }

            try {
              const response = await fetchWithRetry('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
                },
                body: JSON.stringify({
                  model: 'gpt-4o',
                  max_tokens: 2000,
                  messages: [{
                    role: 'system',
                    content: 'You are an expert code reviewer focusing on code quality, best practices, and maintainability.'
                  }, {
                    role: 'user',
                    content: `Review this PR diff for:
            1. Code style and consistency
            2. Best practices violations
            3. Potential bugs and edge cases
            4. Test coverage gaps

            Be concise. Format as markdown with severity levels (üî¥ Critical, üü° Warning, üü¢ Suggestion).

            Files changed:
            ${files}

            Diff:
            ${diff.substring(0, 60000)}`
                  }]
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                console.log('OpenAI API error:', response.status, errorText);
                core.setOutput('result', `‚ö†Ô∏è GPT-4 API error: ${response.status}`);
                core.setOutput('success', 'false');
                return;
              }

              const data = await response.json();

              if (data.choices && data.choices[0] && data.choices[0].message) {
                core.setOutput('result', data.choices[0].message.content);
                core.setOutput('success', 'true');
              } else {
                core.setOutput('result', '‚ö†Ô∏è GPT-4 returned empty response');
                core.setOutput('success', 'false');
              }
            } catch (error) {
              console.log('GPT-4 error:', error.message);
              core.setOutput('result', `‚ö†Ô∏è GPT-4 error: ${error.message}`);
              core.setOutput('success', 'false');
            }

  gemini-review:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      review: ${{ steps.review.outputs.result }}
      success: ${{ steps.review.outputs.success }}
    steps:
      - name: Gemini Security & Documentation Review
        id: review
        uses: actions/github-script@v7
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        with:
          script: |
            const diff = Buffer.from('${{ needs.prepare.outputs.diff }}', 'base64').toString('utf-8');
            const files = `${{ needs.prepare.outputs.files }}`;

            if (!process.env.GOOGLE_API_KEY) {
              core.setOutput('result', '‚ö†Ô∏è Google API key not configured');
              core.setOutput('success', 'false');
              return;
            }

            // Retry with exponential backoff for 429/5xx errors
            async function fetchWithRetry(url, options, maxRetries = 3) {
              for (let attempt = 0; attempt <= maxRetries; attempt++) {
                const response = await fetch(url, options);
                if (response.ok) return response;
                if ((response.status === 429 || response.status >= 500) && attempt < maxRetries) {
                  const retryAfter = response.headers.get('retry-after');
                  const parsedRetry = retryAfter ? parseInt(retryAfter) : NaN;
                  const delay = !isNaN(parsedRetry) ? parsedRetry * 1000 : Math.pow(2, attempt) * 1000;
                  console.log(`Rate limited (${response.status}). Retry ${attempt + 1}/${maxRetries} in ${delay}ms`);
                  await new Promise(r => setTimeout(r, delay + Math.random() * 500));
                  continue;
                }
                return response;
              }
            }

            try {
              const response = await fetchWithRetry(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${process.env.GOOGLE_API_KEY}`,
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    contents: [{
                      parts: [{
                        text: `You are an expert code reviewer focusing on documentation and security. Review this PR diff for:
            1. Missing or unclear documentation
            2. Security vulnerabilities (OWASP Top 10)
            3. Input validation issues
            4. Sensitive data exposure risks

            Be concise. Format as markdown with severity levels (üî¥ Critical, üü° Warning, üü¢ Suggestion).

            Files changed:
            ${files}

            Diff:
            ${diff.substring(0, 60000)}`
                      }]
                    }],
                    generationConfig: {
                      maxOutputTokens: 2000
                    }
                  })
                }
              );

              if (!response.ok) {
                const errorText = await response.text();
                console.log('Gemini API error:', response.status, errorText);
                core.setOutput('result', `‚ö†Ô∏è Gemini API error: ${response.status}`);
                core.setOutput('success', 'false');
                return;
              }

              const data = await response.json();

              if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                const text = data.candidates[0].content.parts[0].text;
                core.setOutput('result', text);
                core.setOutput('success', 'true');
              } else {
                core.setOutput('result', '‚ö†Ô∏è Gemini returned empty response');
                core.setOutput('success', 'false');
              }
            } catch (error) {
              console.log('Gemini error:', error.message);
              core.setOutput('result', `‚ö†Ô∏è Gemini error: ${error.message}`);
              core.setOutput('success', 'false');
            }

  grok-review:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      review: ${{ steps.review.outputs.result }}
      success: ${{ steps.review.outputs.success }}
    steps:
      - name: Grok Creative & Edge Case Review
        id: review
        uses: actions/github-script@v7
        env:
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
        with:
          script: |
            const diff = Buffer.from('${{ needs.prepare.outputs.diff }}', 'base64').toString('utf-8');
            const files = `${{ needs.prepare.outputs.files }}`;

            if (!process.env.XAI_API_KEY) {
              core.setOutput('result', '‚ö†Ô∏è X.AI API key not configured');
              core.setOutput('success', 'false');
              return;
            }

            // Retry with exponential backoff for 429/5xx errors
            async function fetchWithRetry(url, options, maxRetries = 3) {
              for (let attempt = 0; attempt <= maxRetries; attempt++) {
                const response = await fetch(url, options);
                if (response.ok) return response;
                if ((response.status === 429 || response.status >= 500) && attempt < maxRetries) {
                  const retryAfter = response.headers.get('retry-after') || response.headers.get('x-ratelimit-reset-requests');
                  const parsedRetry = retryAfter ? parseInt(retryAfter) : NaN;
                  const delay = !isNaN(parsedRetry) ? parsedRetry * 1000 : Math.pow(2, attempt) * 1000;
                  console.log(`Rate limited (${response.status}). Retry ${attempt + 1}/${maxRetries} in ${delay}ms`);
                  await new Promise(r => setTimeout(r, delay + Math.random() * 500));
                  continue;
                }
                return response;
              }
            }

            try {
              const response = await fetchWithRetry('https://api.x.ai/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${process.env.XAI_API_KEY}`
                },
                body: JSON.stringify({
                  model: 'grok-2-latest',
                  max_tokens: 2000,
                  messages: [{
                    role: 'system',
                    content: 'You are Grok, an AI that thinks outside the box. Look for unconventional issues others might miss. Be insightful and slightly witty.'
                  }, {
                    role: 'user',
                    content: `Review this PR diff for:
            1. Edge cases and corner cases
            2. Unconventional attack vectors
            3. Race conditions and timing issues
            4. Creative improvements and optimizations

            Be concise but insightful. Format as markdown with severity levels (üî¥ Critical, üü° Warning, üü¢ Suggestion).

            Files changed:
            ${files}

            Diff:
            ${diff.substring(0, 60000)}`
                  }]
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                console.log('Grok API error:', response.status, errorText);
                core.setOutput('result', `‚ö†Ô∏è Grok API error: ${response.status}`);
                core.setOutput('success', 'false');
                return;
              }

              const data = await response.json();

              if (data.choices && data.choices[0] && data.choices[0].message) {
                core.setOutput('result', data.choices[0].message.content);
                core.setOutput('success', 'true');
              } else {
                core.setOutput('result', '‚ö†Ô∏è Grok returned empty response');
                core.setOutput('success', 'false');
              }
            } catch (error) {
              console.log('Grok error:', error.message);
              core.setOutput('result', `‚ö†Ô∏è Grok error: ${error.message}`);
              core.setOutput('success', 'false');
            }

  # Step 3: Consolidate and post review
  consolidate:
    needs: [prepare, claude-review, gpt4-review, gemini-review, grok-review]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Post consolidated review
        uses: actions/github-script@v7
        with:
          script: |
            // Safely get outputs, handling potential undefined
            const claudeReview = `${{ needs.claude-review.outputs.review }}` || '_Not available_';
            const gpt4Review = `${{ needs.gpt4-review.outputs.review }}` || '_Not available_';
            const geminiReview = `${{ needs.gemini-review.outputs.review }}` || '_Not available_';
            const grokReview = `${{ needs.grok-review.outputs.review }}` || '_Not available_';

            // Count successful reviews
            const claudeOk = '${{ needs.claude-review.outputs.success }}' === 'true';
            const gpt4Ok = '${{ needs.gpt4-review.outputs.success }}' === 'true';
            const geminiOk = '${{ needs.gemini-review.outputs.success }}' === 'true';
            const grokOk = '${{ needs.grok-review.outputs.success }}' === 'true';

            const successCount = [claudeOk, gpt4Ok, geminiOk, grokOk].filter(Boolean).length;
            const statusEmoji = successCount === 4 ? '‚úÖ' : successCount > 0 ? '‚ö†Ô∏è' : '‚ùå';
            const hr = '‚Äî'.repeat(40);

            // Smart routing info
            const primaryAI = '${{ needs.prepare.outputs.primary_ai }}' || 'all';
            const focusArea = '${{ needs.prepare.outputs.focus_area }}' || 'general';
            const routingNote = primaryAI !== 'all'
              ? `Smart routing detected **${focusArea}** changes, prioritizing **${primaryAI}** review.`
              : '';

            // Triage: Extract and count findings by severity
            const allReviewText = [claudeReview, gpt4Review, geminiReview, grokReview].join('\n');
            const criticalCount = (allReviewText.match(/üî¥|CRITICAL/gi) || []).length;
            const warningCount = (allReviewText.match(/üü°|WARNING/gi) || []).length;
            const suggestionCount = (allReviewText.match(/üü¢|SUGGESTION/gi) || []).length;

            // Build triage section
            let triageSection = '';
            if (criticalCount > 0 || warningCount > 0) {
              triageSection = [
                '## üìä Triage Summary',
                '',
                '| Severity | Count | Action |',
                '|----------|-------|--------|',
                criticalCount > 0 ? `| üî¥ Critical | ${criticalCount} | **Must fix before merge** |` : null,
                warningCount > 0 ? `| üü° Warning | ${warningCount} | Should address |` : null,
                suggestionCount > 0 ? `| üü¢ Suggestion | ${suggestionCount} | Consider for improvement |` : null,
                '',
                criticalCount > 0 ? '> ‚ö†Ô∏è **This PR has critical issues that should be resolved before merging.**' : null,
                '',
                hr,
                ''
              ].filter(p => p !== null).join('\n');
            }

            const parts = [
              `# ü§ñ Multi-AI Code Review ${statusEmoji}`,
              '',
              `This PR has been reviewed by ${successCount}/4 AI models, each with a different focus area.`,
              routingNote ? '' : null,
              routingNote || null,
              '',
              triageSection || null,
              triageSection ? '' : hr,
              triageSection ? '' : '',
              '## üß† Claude (Architecture & Design)',
              claudeReview,
              '',
              hr,
              '',
              '## üíª GPT-4 (Code Quality & Best Practices)',
              gpt4Review,
              '',
              hr,
              '',
              '## üîí Gemini (Documentation & Security)',
              geminiReview,
              '',
              hr,
              '',
              '## üöÄ Grok (Edge Cases & Creative Insights)',
              grokReview,
              '',
              hr,
              '',
              '<details>',
              '<summary>‚ÑπÔ∏è About this review</summary>',
              '',
              'This automated review uses multiple AI models to provide comprehensive feedback:',
              '- **Claude** focuses on architecture, scalability, and system design',
              '- **GPT-4** focuses on code quality, best practices, and testing',
              '- **Gemini** focuses on documentation and security vulnerabilities',
              '- **Grok** focuses on edge cases and unconventional issues',
              '',
              'Each model brings a unique perspective. Consider all feedback but use your judgment.',
              '',
              `**Status**: ${successCount}/4 AIs responded successfully`,
              '',
              '</details>',
              '',
              hr,
              '',
              '*üí¨ Tag an AI to continue: `@ai:claude` `@ai:gpt4` `@ai:gemini` `@ai:grok` `@ai:all`*'
            ];

            // Filter null entries and join
            const body = parts.filter(p => p !== null).join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ needs.prepare.outputs.pr_number }},
              body: body
            });

            // Fail-fast: Check for critical findings
            const allReviews = [claudeReview, gpt4Review, geminiReview, grokReview].join('\n');
            const hasCritical = /CRITICAL|üî¥/i.test(allReviews);

            if (hasCritical) {
              console.log('Critical findings detected - adding label');

              // Add "needs-attention" label
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: ${{ needs.prepare.outputs.pr_number }},
                  labels: ['ai-review-critical']
                });
              } catch (e) {
                console.log('Could not add label (may not exist):', e.message);
              }

              // Post a warning comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.prepare.outputs.pr_number }},
                body: '‚ö†Ô∏è **Critical findings detected** - Please address the issues marked with üî¥ CRITICAL before merging.'
              });
            }
